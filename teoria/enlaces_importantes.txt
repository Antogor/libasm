Teoria completa sobre ASM:
	https://www.exabyteinformatica.com/uoc/Informatica/Estructura_de_computadores/Estructura_de_computadores_(Modulo_6).pdf

Estructura de computadores:
	http://cv.uoc.edu/annotation/8255a8c320f60c2bfd6c9f2ce11b2e7f/619469/PID_00218273/PID_00218273.html#w31aac15b9c17c17

Tabla de llamadas al sistema de linux:
	https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/

Curso ASM:
	https://www.youtube.com/watch?v=mhqDaGCWeFc&list=PLZw5VfkTcc8NhxZoItF3u91CQaUzo7Wvn&index=1

Manual NASM:
	https://www.nasm.us/doc/nasmdoci.html

Tutorial NASM:
	https://cs.lmu.edu/~ray/notes/nasmtutorial/

Curso NASM:
	https://www.youtube.com/watch?v=cnoCnJ6xAHE&list=PLJy7--EGFrT1EK1wgvIJKFP5EgiIW2eDm

INSTRUCCIONES:
	; Save register
	push	REG
	pop		REG

	; Set register value
	mov		REG, VALUE	; DEST = VALUE

	; Common operations
	add		DEST, VALUE	; DEST = DEST + VALUE
	sub		-			; DEST = DEST - VALUE
	inc		REG			; REG++
	dec		-			; REG--
	and		DEST, REG	; DEST = DEST & REG
	xor		-			; DEST = DEST ^ REG
	xor		REG, REG	; = mov	REG, 0
	mul		REG			; REG = REG * RAX
	div		REG			; REG = REG / RAX

	; Dereferenced value
		[REG]		; = *REG

	; Compare
	cmp	REG, VALUE		; Set flags used by jmp variants

	; Label
	label:
			jmp	label	; next jumps depends on compare flags from cmp
			je	-		; is equal
			jne	-		; is not equal
			jl	-		; < VALUE
			jle	-		; <= VALUE
			jz	-		; = 0
			jnz	-		; != 0
			jg	-		; > VALUE
			jge	-		; >= VALUE

FUNCIONES:
	; Function call
	call	FUNCTION

	; Parameters registers
	RDI RSI RDX RCX R8 R9

	; Register to preserve
	RBP RBX R12 R13 R14 R15	; You **MUST** push/pop them if you use them

	; Return register
	RAX

	; syscall
	mov		rax, CODE	; Then RDI, RSI etc.. for params
						; Add 0x2000000 to the syscall number, see table below
	syscall